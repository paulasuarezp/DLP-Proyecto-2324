Grammar.g4
En sentencias:
	| 'switch' cond=expr '{' cases+=switchCase* 'default:' d+=sentence* 'break;' '}'	{ $ast = new Switch($cond.ast, $cases, $d); }
	;
// ##FIN sentence


	
nuevas producciones:

	switchCase returns [SwitchCase ast]
	: 'case' expr ':' b+=sentence* 	'break;'									{ $ast = new SwitchCase($expr.ast, $b); }
	;									{ $ast = $complexAssignment.ast ; }
	

abstractGrammar:
switch: sentence -> value:expression cases:switchCase* defaultCase:sentence*;

switchCase -> value:expression body:sentence*;


typechecking:

	// class Switch(Expression value, List<SwitchCase> cases, List<Sentence> defaultCase)
	// phase TypeChecking { FunctionDefinition owner }
	@Override
	public Object visit(Switch switchValue, Object param) {

		for (var switchCase : switchValue.getCases()) {
			switchCase.setOwner(switchValue.getOwner());
		}

		for (var sentence : switchValue.getDefaultCase()) {
			sentence.setOwner(switchValue.getOwner());
		}

		super.visit(switchValue, param);

		boolean isPrimitive = isPrimitive(switchValue.getValue().getType());
		String errorMessage = String.format("El tipo de la expresión del switch '%s' debe de ser un tipo simple (INTEGER, DOUBLE o CHARACTER), no puede ser %s.", 
										switchValue.getValue(),
										getTypeName(switchValue.getValue().getType()));
		predicate(isPrimitive, errorMessage, switchValue);
		boolean sameType = switchValue.getCases().stream().allMatch(s -> checkSameType(switchValue.getValue().getType(), s.getValue().getType()));
		errorMessage = String.format("El tipo de la expresión del switch '%s' debe de ser igual al tipo de las expresiones de todos los casos.", 
										switchValue.getValue());
										
		predicate(sameType, errorMessage, switchValue);

		// switchValue.getValue().accept(this, param);
		// switchValue.getCases().forEach(switchCase -> switchCase.accept(this, param));
		// switchValue.getDefaultCase().forEach(sentence -> sentence.accept(this, param));
		

		return null;
	}

	// class SwitchCase(Expression value, List<Sentence> body)
	@Override
	public Object visit(SwitchCase switchCase, Object param) {

		for (var sentence : switchCase.getBody()) {
			sentence.setOwner(switchCase.getOwner());
		}

		// switchCase.getValue().accept(this, param);
		// switchCase.getBody().forEach(sentence -> sentence.accept(this, param));
		super.visit(switchCase, param);

		return null;
	}

	
	
en la funcion de codigo execute:

// class Switch(Expression value, List<SwitchCase> cases, List<Sentence> defaultCase)
	// phase TypeChecking { FunctionDefinition owner }
	@Override
	public Object visit(Switch switchValue, Object param) {
		labelCount++;
		String defaultLabel = MaplUtils.formatLabel("defaultCase_", labelCount);
		String endLabel = MaplUtils.formatLabel("endSwitch_", labelCount);

		out("\n#line " + switchValue.start().getLine());
		
		List<String> caseLabels = new ArrayList<String>();
		
		int x = 0;

		for(SwitchCase sc : switchValue.getCases()) {
			labelCount++;
			String caseLabel = MaplUtils.formatLabel("switchCase_", labelCount);
			caseLabels.add(caseLabel);
			out("\n#line " + switchValue.getCases().get(x).start().getLine());
			value(switchValue.getValue());
			value(sc.getValue());
			out("EQ" + MaplUtils.maplSuffix(switchValue.getValue().getType()));
			out("JNZ " + caseLabel);
			x++;
		}
	

		out("JMP " + defaultLabel);

		for(int i = 0; i < switchValue.getCases().size(); i++) {
			out("'case " + i + ":\n");
			out(caseLabels.get(i) + ":");
			execute(switchValue.getCases().get(i).body());
			out("JMP " + endLabel);
		}

		
		out(defaultLabel + ":");
		execute(switchValue.defaultCase());

		out(endLabel + ":");

		return null;
	}